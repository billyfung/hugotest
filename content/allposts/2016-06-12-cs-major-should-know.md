---
title: What Every Computer Science Major Should Know
subtitle: 
date: '2016-06-12'
slug: cs-should-know
---

So I'm not a computer science major, but I figured it would be enjoyable to go
through [this list][2] and see where I might have gaps in my knowledge. Matt
also says that it would be a good self-study guide, which makes it easy to
always go back to re-evaluate what you can learn next.

# Things I know/have

  * portfolio vs resume, this personal website? Github.
  * technical communication, I try to mix it up with this blog
  * engineering core, huzzah my engineering degree

## Navigating Unix

  * emacs/vim editing 
  * Makefile for a project
  * shell scripts
  * 5 folders consuming most space in directory
  * capitalizing names in command line
  * replace spaces with underscores within directory

## Sysadmin

  * install Linux distro
  * configure and compile Linux kernel
  * set up web server (nginx)

## Programming Languages

  * C, I can program C halfassed, but I have been spending time with Rust and learning how complicated and difficult C actually is, when doing it properly
  * Javascript, semantic web yay!
  * Scala/Java, I somewhat know these, but not enough to be dangerous
  * Haskell, definitely a growing interest in learning this as my only functional language, oh apparently it's a Hindley-Milner type
  * Assembly, I love learning about compilers and groking the low level stuff
  * generative programming (macros)
  * lexical and dynamic scope

### Discrete math

  * trees
  * graphs
  * automata
  * proofs
  * crypoto protocols, fun stuff!

### Data structures & algos

  * greedy vs dynamic, designing algos
  * hash tables
  * linked lists
  * trees
  * BST
  * directed/undirect graphs
  * imperative and functional versions

### Theory

  * bounding a problem
  * finding the complexity 
  * regex
  * Turing machines
  * lambda calculus

### Architecture

  * transistors, gates, adders, muxes, flip flops, ALU, cache, RAM
  * GPU model as well
  * hardware memory management 
  * design an implement a CPU, definitely done this one

### Operating Systems

  * filesystems
  * resource management
  * I don't know much here…

### Security

  * social engineering
  * buffer overflows
  * integer overflow
  * race conditions (that's racist!)
  * iptables firewall
  * password selection

### Networking

  * network protocol standards, IPv4 IPv6, DNS, SMTP, DNS
  * HTTP client and daemon
  * wireshark sniffing
  * packet collision resolution

### Crypotography

  * symmetric key system
  * public-key system
  * hash functions
  * salt and hash passwords
  * acquire sufficiently random number
  * implement RSA
  * web client that connects over SSL

### Software testing

  * test cases for everything!

### User experience design

  * interfaces to make executing task easier, depending on frequency of the task and importance

### Visualization

  * Tufte!

### Software Engineering

  * working in a group, collab with version control
  * going through a large codebase with a team, being both leader and follower

  * robotics, well I did study this…

  * AI, machine learning, NLP, data mining, stats for all that

  * databases! relational theory

# Things I don't know

  * compose processes with pipes
  * finding files with duplicate contents/Unix
  * report last ten errant accesses to web server from specific IP
  * routing microphone input over the network to another computer's speakers
  * `dig, ping, traceroute` in depth troubleshooting
  * DNS daemon
  * cut and crimp network cable (??? I can do normal cables…)
  * implement a programming language
  * Lisp dialect
  * Squeak, apparently the purest of OO langs
  * Standard ML, Hindley-Milner type system, I've never even heard of this
  * logic programming
  * C++, template meta-programming? I have no idea what that is so I must not know C++
  * dynamic dispatch
  * formal grammars
  * context-free languages
  * NP problems by reduction to SAT and SAT solvers 
  * finite state automata, pushdown automata
  * how kernels handle system calls, paging, scheduling, context-switching
  * page handling policy
  * creating a filesystem
  * design a scheduler
  * mechanics of building a transmission protocol, reliable and unreliable
  * implement DNS resolver and server
  * SMTP mailer from the command line
  * congestion control
  * code injection vulnerabilities
  * privilege confusion
  * challenge-response authentication
  * digital signature algo
  * threshold cryptosystem
  * create digital cert and set up https in apache 
  * parallelism, including GPU, although I have touched some CUDA
  * OpenCL
  * large scale, MPI 
  * theorem prover, no idea what this is
  * something about theorem prover and coding style, formal methods
  * implementing a ray tracer
  * project 3d perspective into wireframe engine
  * z-buffer rendering
  * probably still need to learn lots more about relational algebra and relational calculus

Okay that was a fun list, will have to revisit this in the future to see what
more I learn, and what more I should learn. I think it's not too shabby for
somebody who isn't a computer scientist.

[2]: http://matt.might.net/articles/what-cs-majors-should-know/
